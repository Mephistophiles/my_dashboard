use anyhow::Result;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct SolarWindData {
    pub speed: f64,                  // –∫–º/—Å
    pub density: f64,                // —á–∞—Å—Ç–∏—Ü/—Å–º¬≥
    pub temperature: f64,            // –ö
    pub magnetic_field: Option<f64>, // –Ω–¢–ª (–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –≤ SWEPAM API)
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug, Serialize, Deserialize)]
pub struct GeomagneticData {
    pub kp_index: f64,                // –ì–µ–æ–º–∞–≥–Ω–∏—Ç–Ω—ã–π –∏–Ω–¥–µ–∫—Å
    pub aurora_activity: f64,         // –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π (0-10)
    pub solar_radiation: Option<f64>, // –°–æ–ª–Ω–µ—á–Ω–∞—è —Ä–∞–¥–∏–∞—Ü–∏—è (–Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ –≤ Kp API)
    pub timestamp: DateTime<Utc>,
}

#[derive(Debug)]
pub struct AuroraForecast {
    pub visibility_probability: f64, // –í–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤–∏–¥–∏–º–æ—Å—Ç–∏ —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π
    pub intensity_level: String,     // –£—Ä–æ–≤–µ–Ω—å –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
    pub best_viewing_hours: Vec<usize>, // –õ—É—á—à–∏–µ —á–∞—Å—ã –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è
    pub conditions: String,          // –£—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è
}

// –°—Ç—Ä—É–∫—Ç—É—Ä—ã –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞ NOAA API
#[derive(Debug, Serialize, Deserialize)]
struct SwepamRecord {
    #[serde(rename = "time_tag")]
    time_tag: String,
    #[serde(rename = "dsflag")]
    dsflag: i32,
    #[serde(rename = "dens")]
    dens: Option<f64>,
    #[serde(rename = "speed")]
    speed: Option<f64>,
    #[serde(rename = "temperature")]
    temperature: Option<f64>,
}

#[derive(Debug, Serialize, Deserialize)]
struct KpRecord {
    #[serde(rename = "time_tag")]
    time_tag: String,
    #[serde(rename = "kp_index")]
    kp_index: f64,
}

pub async fn print_solar_data() -> Result<()> {
    match fetch_solar_wind_data().await {
        Ok(solar_wind) => {
            println!(
                "üåû –°–æ–ª–Ω–µ—á–Ω—ã–π –≤–µ—Ç–µ—Ä: üí®{:.1}–∫–º/—Å  üìä{:.1}—á–∞—Å—Ç–∏—Ü/—Å–º¬≥  üå°Ô∏è{:.0}K  üïê{}",
                solar_wind.speed,
                solar_wind.density,
                solar_wind.temperature,
                solar_wind.timestamp.format("%H:%M")
            );
        }
        Err(e) => {
            println!("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞: {}", e);
        }
    }

    match fetch_geomagnetic_data().await {
        Ok(geomagnetic) => {
            println!(
                "üåç –ì–µ–æ–º–∞–≥–Ω–∏—Ç–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ: üß≤Kp {:.1}  üåå–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–∏—è–Ω–∏–π {:.1}/10  üïê{}",
                geomagnetic.kp_index,
                geomagnetic.aurora_activity,
                geomagnetic.timestamp.format("%H:%M")
            );
        }
        Err(e) => {
            println!("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –≥–µ–æ–º–∞–≥–Ω–∏—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö: {}", e);
        }
    }

    match predict_aurora().await {
        Ok(forecast) => {
            println!(
                "üåå –ü—Ä–æ–≥–Ω–æ–∑ —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π: {}%  üìä{}  üí°{}",
                (forecast.visibility_probability * 100.0) as i32,
                forecast.intensity_level,
                forecast.conditions
            );

            if !forecast.best_viewing_hours.is_empty() {
                let mut intervals = Vec::new();
                let mut start = forecast.best_viewing_hours[0];
                let mut end = start;

                for &hour in &forecast.best_viewing_hours[1..] {
                    if hour == end + 1 {
                        end = hour;
                    } else {
                        if start == end {
                            intervals.push(format!("{:02}:00", start));
                        } else {
                            intervals.push(format!("{:02}:00-{:02}:00", start, end));
                        }
                        start = hour;
                        end = hour;
                    }
                }
                if start == end {
                    intervals.push(format!("{:02}:00", start));
                } else {
                    intervals.push(format!("{:02}:00-{:02}:00", start, end));
                }

                println!("   üïê –õ—É—á—à–∏–µ —á–∞—Å—ã –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è: {}", intervals.join(", "));
            }
        }
        Err(e) => {
            println!("   ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≥–Ω–æ–∑–∞ —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π: {}", e);
        }
    }

    Ok(())
}

async fn fetch_solar_wind_data() -> Result<SolarWindData> {
    let url = "https://services.swpc.noaa.gov/json/ace/swepam/ace_swepam_1h.json";
    let response = reqwest::get(url).await?;

    if !response.status().is_success() {
        return Err(anyhow::anyhow!(
            "HTTP {}: {}",
            response.status(),
            response.text().await?
        ));
    }

    let text = response.text().await?;

    // –ü–æ–ø—Ä–æ–±—É–µ–º –ø–∞—Ä—Å–∏—Ç—å JSON —Å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    let all_records: Vec<SwepamRecord> = match serde_json::from_str::<Vec<SwepamRecord>>(&text) {
        Ok(records) => records,
        Err(e) => {
            return Err(anyhow::anyhow!("Failed to parse solar wind JSON: {}", e));
        }
    };

    if all_records.is_empty() {
        return Err(anyhow::anyhow!("No solar wind data available"));
    }

    // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 –∑–∞–ø–∏—Å–µ–π –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞
    let start_idx = if all_records.len() > 50 {
        all_records.len() - 50
    } else {
        0
    };
    let records = &all_records[start_idx..];

    // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–∏—Å—å —Å –≤–∞–ª–∏–¥–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
    let latest_record = records
        .iter()
        .find(|r| r.dsflag == 0 && r.dens.is_some() && r.speed.is_some() && r.temperature.is_some())
        .ok_or_else(|| anyhow::anyhow!("No valid solar wind data found"))?;

    let timestamp =
        match chrono::NaiveDateTime::parse_from_str(&latest_record.time_tag, "%Y-%m-%dT%H:%M:%S") {
            Ok(dt) => dt.and_utc(),
            Err(e) => {
                return Err(anyhow::anyhow!(
                    "Failed to parse timestamp '{}': {}",
                    latest_record.time_tag,
                    e
                ));
            }
        };

    Ok(SolarWindData {
        speed: latest_record.speed.unwrap(),
        density: latest_record.dens.unwrap(),
        temperature: latest_record.temperature.unwrap(),
        magnetic_field: None, // –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ –º–∞–≥–Ω–∏—Ç–Ω–æ–º –ø–æ–ª–µ –≤ SWEPAM
        timestamp,
    })
}

async fn fetch_geomagnetic_data() -> Result<GeomagneticData> {
    let url = "https://services.swpc.noaa.gov/json/planetary_k_index_1m.json";
    let response = reqwest::get(url).await?;

    if !response.status().is_success() {
        return Err(anyhow::anyhow!(
            "HTTP {}: {}",
            response.status(),
            response.text().await?
        ));
    }

    let text = response.text().await?;

    // –ü–æ–ø—Ä–æ–±—É–µ–º –ø–∞—Ä—Å–∏—Ç—å JSON —Å –±–æ–ª–µ–µ –ø–æ–¥—Ä–æ–±–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫
    let all_records: Vec<KpRecord> = match serde_json::from_str::<Vec<KpRecord>>(&text) {
        Ok(records) => records,
        Err(e) => {
            return Err(anyhow::anyhow!("Failed to parse geomagnetic JSON: {}", e));
        }
    };

    if all_records.is_empty() {
        return Err(anyhow::anyhow!("No geomagnetic data available"));
    }

    // –ë–µ—Ä–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 50 –∑–∞–ø–∏—Å–µ–π –¥–ª—è —É—Å–∫–æ—Ä–µ–Ω–∏—è –ø–∞—Ä—Å–∏–Ω–≥–∞
    let start_idx = if all_records.len() > 50 {
        all_records.len() - 50
    } else {
        0
    };
    let records = &all_records[start_idx..];

    // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω—é—é –∑–∞–ø–∏—Å—å
    let latest_record = &records[records.len() - 1];

    let timestamp =
        match chrono::NaiveDateTime::parse_from_str(&latest_record.time_tag, "%Y-%m-%dT%H:%M:%S") {
            Ok(dt) => dt.and_utc(),
            Err(e) => {
                return Err(anyhow::anyhow!(
                    "Failed to parse timestamp '{}': {}",
                    latest_record.time_tag,
                    e
                ));
            }
        };

    // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π –Ω–∞ –æ—Å–Ω–æ–≤–µ Kp –∏–Ω–¥–µ–∫—Å–∞
    let aurora_activity = if latest_record.kp_index >= 5.0 {
        8.0 + (latest_record.kp_index - 5.0) * 0.4
    } else if latest_record.kp_index >= 3.0 {
        4.0 + (latest_record.kp_index - 3.0) * 2.0
    } else {
        latest_record.kp_index * 1.33
    }
    .min(10.0);

    Ok(GeomagneticData {
        kp_index: latest_record.kp_index,
        aurora_activity,
        solar_radiation: None, // –ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –æ —Å–æ–ª–Ω–µ—á–Ω–æ–π —Ä–∞–¥–∏–∞—Ü–∏–∏
        timestamp,
    })
}

fn calculate_aurora_activity(solar_wind: &SolarWindData, geomagnetic: &GeomagneticData) -> f64 {
    let mut activity = 0.0;

    // –í–ª–∏—è–Ω–∏–µ Kp –∏–Ω–¥–µ–∫—Å–∞ (0-9)
    activity += (geomagnetic.kp_index / 9.0).min(1.0) * 6.0;

    // –í–ª–∏—è–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞
    if solar_wind.speed > 600.0 {
        activity += 2.0;
    } else if solar_wind.speed > 400.0 {
        activity += 1.0;
    }

    // –í–ª–∏—è–Ω–∏–µ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞
    if solar_wind.density > 10.0 {
        activity += 2.0;
    } else if solar_wind.density > 5.0 {
        activity += 1.0;
    }

    activity.min(10.0)
}

pub async fn predict_aurora() -> Result<AuroraForecast> {
    let solar_wind = fetch_solar_wind_data().await?;
    let geomagnetic = fetch_geomagnetic_data().await?;

    // –ò—Å–ø–æ–ª—å–∑—É–µ–º —Ñ—É–Ω–∫—Ü–∏—é calculate_aurora_activity –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    let activity = calculate_aurora_activity(&solar_wind, &geomagnetic);
    
    // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (0-10) –≤ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å (0-1)
    let probability = (activity / 10.0).min(1.0);

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Ä–æ–≤–µ–Ω—å –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
    let intensity_level = if probability > 0.8 {
        "–û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è"
    } else if probability > 0.6 {
        "–í—ã—Å–æ–∫–∞—è"
    } else if probability > 0.4 {
        "–£–º–µ—Ä–µ–Ω–Ω–∞—è"
    } else if probability > 0.2 {
        "–ù–∏–∑–∫–∞—è"
    } else {
        "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è"
    }
    .to_string();

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —É—Å–ª–æ–≤–∏—è
    let conditions = if probability > 0.6 {
        "–û—Ç–ª–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π"
    } else if probability > 0.4 {
        "–•–æ—Ä–æ—à–∏–µ —É—Å–ª–æ–≤–∏—è, –≤–æ–∑–º–æ–∂–Ω—ã —Å–∏—è–Ω–∏—è"
    } else if probability > 0.2 {
        "–£–º–µ—Ä–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è, —Å–∏—è–Ω–∏—è –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã"
    } else {
        "–ü–ª–æ—Ö–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è —Å–∏—è–Ω–∏–π"
    }
    .to_string();

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –ª—É—á—à–∏–µ —á–∞—Å—ã –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è (–Ω–æ—á–Ω—ã–µ —á–∞—Å—ã)
    let best_hours = vec![22, 23, 0, 1, 2, 3, 4, 5];

    Ok(AuroraForecast {
        visibility_probability: probability,
        intensity_level,
        best_viewing_hours: best_hours,
        conditions,
    })
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::{Datelike, Timelike};

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö
    fn create_test_solar_wind_data() -> SolarWindData {
        SolarWindData {
            speed: 500.0,
            density: 5.0,
            temperature: 250000.0,
            magnetic_field: None,
            timestamp: Utc::now(),
        }
    }

    fn create_test_geomagnetic_data() -> GeomagneticData {
        GeomagneticData {
            kp_index: 3.0,
            aurora_activity: 4.0,
            solar_radiation: None,
            timestamp: Utc::now(),
        }
    }

    fn create_high_activity_solar_wind() -> SolarWindData {
        SolarWindData {
            speed: 700.0,  // –í—ã—Å–æ–∫–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å
            density: 15.0, // –í—ã—Å–æ–∫–∞—è –ø–ª–æ—Ç–Ω–æ—Å—Ç—å
            temperature: 300000.0,
            magnetic_field: None,
            timestamp: Utc::now(),
        }
    }

    fn create_high_kp_geomagnetic_data() -> GeomagneticData {
        GeomagneticData {
            kp_index: 7.0, // –í—ã—Å–æ–∫–∏–π Kp –∏–Ω–¥–µ–∫—Å
            aurora_activity: 8.0,
            solar_radiation: None,
            timestamp: Utc::now(),
        }
    }

    #[test]
    fn test_solar_wind_data_validation() {
        let solar_wind = create_test_solar_wind_data();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—É–º–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã
        assert!(solar_wind.speed > 0.0 && solar_wind.speed < 2000.0);
        assert!(solar_wind.density > 0.0 && solar_wind.density < 100.0);
        assert!(solar_wind.temperature > 0.0 && solar_wind.temperature < 1000000.0);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ magnetic_field –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ None
        assert!(solar_wind.magnetic_field.is_none());
    }

    #[test]
    fn test_geomagnetic_data_validation() {
        let geomagnetic = create_test_geomagnetic_data();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—É–º–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã
        assert!(geomagnetic.kp_index >= 0.0 && geomagnetic.kp_index <= 9.0);
        assert!(geomagnetic.aurora_activity >= 0.0 && geomagnetic.aurora_activity <= 10.0);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ solar_radiation –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ None
        assert!(geomagnetic.solar_radiation.is_none());
    }

    #[test]
    fn test_aurora_forecast_structure() {
        let forecast = AuroraForecast {
            visibility_probability: 0.5,
            intensity_level: "–£–º–µ—Ä–µ–Ω–Ω–∞—è".to_string(),
            best_viewing_hours: vec![22, 23, 0, 1, 2, 3, 4, 5],
            conditions: "–•–æ—Ä–æ—à–∏–µ —É—Å–ª–æ–≤–∏—è, –≤–æ–∑–º–æ–∂–Ω—ã —Å–∏—è–Ω–∏—è".to_string(),
        };

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑—É–º–Ω—ã–µ –ø—Ä–µ–¥–µ–ª—ã
        assert!((0.0..=1.0).contains(&forecast.visibility_probability));
        assert!(!forecast.intensity_level.is_empty());
        assert!(!forecast.conditions.is_empty());

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ª—É—á—à–∏–µ —á–∞—Å—ã –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è - –Ω–æ—á–Ω—ã–µ
        for &hour in &forecast.best_viewing_hours {
            assert!((0..=23).contains(&hour));
        }
    }

    #[tokio::test]
    async fn test_predict_aurora_with_test_data() {
        // –°–æ–∑–¥–∞–µ–º mock –¥–∞–Ω–Ω—ã–µ –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        let solar_wind = create_test_solar_wind_data();
        let geomagnetic = create_test_geomagnetic_data();

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ª–æ–≥–∏–∫—É —Ä–∞—Å—á–µ—Ç–∞ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ (–±–µ–∑ —Ä–µ–∞–ª—å–Ω—ã—Ö API –≤—ã–∑–æ–≤–æ–≤)
        let mut probability = 0.0;

        // –í–ª–∏—è–Ω–∏–µ Kp –∏–Ω–¥–µ–∫—Å–∞ (–æ—Å–Ω–æ–≤–Ω–æ–π —Ñ–∞–∫—Ç–æ—Ä)
        probability += (geomagnetic.kp_index / 9.0).min(1.0) * 0.6;

        // –í–ª–∏—è–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞
        let speed_factor = if solar_wind.speed > 600.0 {
            0.3
        } else if solar_wind.speed > 500.0 {
            0.2
        } else if solar_wind.speed > 400.0 {
            0.1
        } else {
            0.0
        };
        probability += speed_factor;

        // –í–ª–∏—è–Ω–∏–µ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞
        let density_factor = if solar_wind.density > 10.0 {
            0.1
        } else if solar_wind.density > 5.0 {
            0.05
        } else {
            0.0
        };
        probability += density_factor;

        probability = probability.min(1.0);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –≤ —Ä–∞–∑—É–º–Ω—ã—Ö –ø—Ä–µ–¥–µ–ª–∞—Ö
        assert!((0.0..=1.0).contains(&probability));

        // –î–ª—è —Ç–µ—Å—Ç–æ–≤—ã—Ö –¥–∞–Ω–Ω—ã—Ö —Å Kp=3.0 –∏ —Å–∫–æ—Ä–æ—Å—Ç—å—é=500.0, –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å > 0
        assert!(probability > 0.0);
    }

    #[tokio::test]
    async fn test_predict_aurora_high_activity() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Å –≤—ã—Å–æ–∫–∏–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
        let _solar_wind = create_high_activity_solar_wind();
        let geomagnetic = create_high_kp_geomagnetic_data();

        let mut probability = 0.0;

        // –í–ª–∏—è–Ω–∏–µ Kp –∏–Ω–¥–µ–∫—Å–∞
        probability += (geomagnetic.kp_index / 9.0).min(1.0) * 0.6;

        // –í–ª–∏—è–Ω–∏–µ —Å–∫–æ—Ä–æ—Å—Ç–∏ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞ (700 –∫–º/—Å > 600)
        probability += 0.3;

        // –í–ª–∏—è–Ω–∏–µ –ø–ª–æ—Ç–Ω–æ—Å—Ç–∏ —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞ (15 > 10)
        probability += 0.1;

        probability = probability.min(1.0);

        // –ü—Ä–∏ –≤—ã—Å–æ–∫–∏—Ö –∑–Ω–∞—á–µ–Ω–∏—è—Ö –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –≤—ã—Å–æ–∫–æ–π
        assert!(probability > 0.8);
    }

    #[test]
    fn test_aurora_intensity_levels() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π –∏–Ω—Ç–µ–Ω—Å–∏–≤–Ω–æ—Å—Ç–∏
        let test_cases = vec![
            (0.9, "–û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è"),
            (0.7, "–í—ã—Å–æ–∫–∞—è"),
            (0.5, "–£–º–µ—Ä–µ–Ω–Ω–∞—è"),
            (0.3, "–ù–∏–∑–∫–∞—è"),
            (0.1, "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è"),
        ];

        for (probability, expected_level) in test_cases {
            let intensity_level = if probability > 0.8 {
                "–û—á–µ–Ω—å –≤—ã—Å–æ–∫–∞—è"
            } else if probability > 0.6 {
                "–í—ã—Å–æ–∫–∞—è"
            } else if probability > 0.4 {
                "–£–º–µ—Ä–µ–Ω–Ω–∞—è"
            } else if probability > 0.2 {
                "–ù–∏–∑–∫–∞—è"
            } else {
                "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è"
            };

            assert_eq!(intensity_level, expected_level);
        }
    }

    #[test]
    fn test_aurora_conditions() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Å–ª–æ–≤–∏–π
        let test_cases = vec![
            (0.7, "–û—Ç–ª–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π"),
            (0.5, "–•–æ—Ä–æ—à–∏–µ —É—Å–ª–æ–≤–∏—è, –≤–æ–∑–º–æ–∂–Ω—ã —Å–∏—è–Ω–∏—è"),
            (0.3, "–£–º–µ—Ä–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è, —Å–∏—è–Ω–∏—è –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã"),
            (0.1, "–ü–ª–æ—Ö–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è —Å–∏—è–Ω–∏–π"),
        ];

        for (probability, expected_condition) in test_cases {
            let conditions = if probability > 0.6 {
                "–û—Ç–ª–∏—á–Ω—ã–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π"
            } else if probability > 0.4 {
                "–•–æ—Ä–æ—à–∏–µ —É—Å–ª–æ–≤–∏—è, –≤–æ–∑–º–æ–∂–Ω—ã —Å–∏—è–Ω–∏—è"
            } else if probability > 0.2 {
                "–£–º–µ—Ä–µ–Ω–Ω—ã–µ —É—Å–ª–æ–≤–∏—è, —Å–∏—è–Ω–∏—è –º–∞–ª–æ–≤–µ—Ä–æ—è—Ç–Ω—ã"
            } else {
                "–ü–ª–æ—Ö–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è —Å–∏—è–Ω–∏–π"
            };

            assert_eq!(conditions, expected_condition);
        }
    }

    #[test]
    fn test_best_viewing_hours() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ª—É—á—à–∏–µ —á–∞—Å—ã –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è - –Ω–æ—á–Ω—ã–µ
        let best_hours = vec![22, 23, 0, 1, 2, 3, 4, 5];

        for &hour in &best_hours {
            // –ù–æ—á–Ω—ã–µ —á–∞—Å—ã: 22-23 –∏ 0-5
            assert!((22..=23).contains(&hour) || (0..=5).contains(&hour));
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —á–∞—Å—ã –∏–¥—É—Ç –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
        for i in 0..best_hours.len() - 1 {
            if best_hours[i] == 23 {
                // –ü–æ—Å–ª–µ 23 –º–æ–∂–µ—Ç –∏–¥—Ç–∏ 0
                assert!(best_hours[i + 1] == 0);
            } else {
                // –í –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Å–ª—É—á–∞—è—Ö —Å–ª–µ–¥—É—é—â–∏–π —á–∞—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –±–æ–ª—å—à–µ
                assert!(best_hours[i + 1] > best_hours[i]);
            }
        }
    }

    #[test]
    fn test_aurora_activity_calculation() {
        let solar_wind = create_test_solar_wind_data();
        let geomagnetic = create_test_geomagnetic_data();

        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ä–∞—Å—á–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π
        let activity = calculate_aurora_activity(&solar_wind, &geomagnetic);
        assert!((0.0..=10.0).contains(&activity));
    }

    #[test]
    fn test_solar_wind_data_structure() {
        let data = create_test_solar_wind_data();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –¥–∞–Ω–Ω—ã—Ö —Å–æ–ª–Ω–µ—á–Ω–æ–≥–æ –≤–µ—Ç—Ä–∞
        assert!(data.speed > 0.0);
        assert!(data.density > 0.0);
        assert!(data.temperature > 0.0);
        assert!(data.timestamp > chrono::Utc::now() - chrono::Duration::days(1));
    }

    #[test]
    fn test_geomagnetic_data_structure() {
        let data = create_test_geomagnetic_data();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –≥–µ–æ–º–∞–≥–Ω–∏—Ç–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
        assert!(data.kp_index >= 0.0 && data.kp_index <= 9.0);
        assert!(data.aurora_activity >= 0.0 && data.aurora_activity <= 10.0);
        assert!(data.timestamp > chrono::Utc::now() - chrono::Duration::days(1));
    }

    #[test]
    fn test_aurora_forecast_creation() {
        let forecast = AuroraForecast {
            visibility_probability: 0.7,
            intensity_level: "–£–º–µ—Ä–µ–Ω–Ω–∞—è".to_string(),
            best_viewing_hours: vec![22, 23, 0, 1],
            conditions: "–•–æ—Ä–æ—à–∏–µ —É—Å–ª–æ–≤–∏—è –¥–ª—è –Ω–∞–±–ª—é–¥–µ–Ω–∏—è".to_string(),
        };

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É –ø—Ä–æ–≥–Ω–æ–∑–∞
        assert!((0.0..=1.0).contains(&forecast.visibility_probability));
        assert!(!forecast.intensity_level.is_empty());
        assert!(!forecast.best_viewing_hours.is_empty());
        assert!(!forecast.conditions.is_empty());
    }

    #[test]
    fn test_swepam_record_parsing() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ SWEPAM –∑–∞–ø–∏—Å–∏
        let json = r#"{
            "time_tag": "2024-06-15T12:00:00",
            "dsflag": 0,
            "dens": 5.2,
            "speed": 450.0,
            "temperature": 150000.0
        }"#;

        let record: SwepamRecord = serde_json::from_str(json).unwrap();
        assert_eq!(record.time_tag, "2024-06-15T12:00:00");
        assert_eq!(record.dsflag, 0);
        assert_eq!(record.dens, Some(5.2));
        assert_eq!(record.speed, Some(450.0));
        assert_eq!(record.temperature, Some(150000.0));
    }

    #[test]
    fn test_kp_record_parsing() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ Kp –∑–∞–ø–∏—Å–∏
        let json = r#"{
            "time_tag": "2024-06-15T12:00:00",
            "kp_index": 3.5
        }"#;

        let record: KpRecord = serde_json::from_str(json).unwrap();
        assert_eq!(record.time_tag, "2024-06-15T12:00:00");
        assert_eq!(record.kp_index, 3.5);
    }

    #[test]
    fn test_timestamp_parsing() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–∞—Ä—Å–∏–Ω–≥ –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö –º–µ—Ç–æ–∫
        let timestamp_str = "2024-06-15T12:00:00";
        let parsed = chrono::NaiveDateTime::parse_from_str(timestamp_str, "%Y-%m-%dT%H:%M:%S");
        assert!(parsed.is_ok());

        let dt = parsed.unwrap().and_utc();
        assert_eq!(dt.year(), 2024);
        assert_eq!(dt.month(), 6);
        assert_eq!(dt.day(), 15);
        assert_eq!(dt.hour(), 12);
    }

    #[test]
    fn test_aurora_probability_calculation() {
        // –¢–µ—Å—Ç–∏—Ä—É–µ–º —Ä–∞—Å—á–µ—Ç –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–∏ —Å–µ–≤–µ—Ä–Ω—ã—Ö —Å–∏—è–Ω–∏–π
        let solar_wind = create_high_activity_solar_wind();
        let geomagnetic = create_high_kp_geomagnetic_data();

        let activity = calculate_aurora_activity(&solar_wind, &geomagnetic);
        let probability = activity / 10.0;

        assert!((0.0..=1.0).contains(&probability));
    }
}
